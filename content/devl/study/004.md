---
layout : post
title : "자료구조 문제풀이 - 16~20"
date: 2023-09-30
summary:
categories : [ 자료구조 ]
tags : [ study ]
---





### 16번 문제

다음 정수들을 순서대로 삽입해서 이진 탐색 트리를 구성했을 떄의 터미널 노드에 해당하는 값들로 옳은 것은?

보기 > `45, 36, 62, 2, 16, 51, 75, 69`

----

* **터미널노드** : 자신의 자식노드가 없는 가장 아랫부분에 위치하는 노드들을 나뭇가지 끝에 붙은 잎과 같다는 의미에서 리프(leaf), 또는 터미널 노드(terminal node)라고 부른다.
  
<span style = "color : #8e8b82; font-size: smaller;">
  직접 그려보았다.
</span>

 ```
              45
             /   \
           36     62
          /      /  \
         2      51  75
          \         /
           16     69      
 ```


|     나의 답      |
|:-------------:|
| 3) 16, 51, 69 | 

<br><br><br>

---



### 17번 문제
다음 트리의 차수(Degree)와 터미널 노드의 수를 올바르게 나열한 것은?

![img.png](../../assets/images/2023-09-30-study005/img.png)


---

#### 노드의 차수(degree)
  * A의 차수 : 3
  * B의 차수 : 2
  * C, D의 차수 : 1

#### 트리의 차수(degree of tree)
  * 트리의 최대 차수 (노드의 차수 중 가장 큰 것을 뽑으면 됨.)
  * A가 가장 최대 차수를 가짐 : 3

#### 기타
  * **노드의 크기** : 자신을 포함한 모든 자손 노드의 개수 (A의 크기 8, B의 크기: 3)
  * **노드의 깊이** : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 (F의 깊이 : 2)
  * **노드의 레벨** : 트리의 특정 깊이를 자기는 노드의 집합 (1레벨 A / 2레벨 B,C,D / 3레벨 E,F,G,E)
  * **트리의 높이** : 루트 노드 중 가장 깊숙히 있는 노드의 깊이 (위 그림은 2)


<br>



|         나의 답         |
|:--------------------:|
| 3) 차수 3 / 터미널 노드 수 4 | 



> 참고사이트  <https://worlf.tistory.com/16>


<br><br><br>



---

### 18번 문제
다음 이진 트리를 전위, 중위, 후위 순회 순서로 방문할 때, 각 순회 7번째에 방문한 노드를 순서대로 나열한 것은?

![img_1.png](../../assets/images/2023-09-30-study005/img_1.png)

---

> 알아야 할 것과 정리

*전위, 순위 ,후위는 루트 노드를 몇번째로 탐색하는 지를 생각하면 편하다고 함.*

#### 트리 전위 순회 (= 깊이우선탐색 = 깊이우선순회)
 * ![전위순회](../../assets/images/2023-09-30-study005/img_8.png)
 * 루트 → 왼쪽 서브트리 전위 순회 → 오른쪽 서브트리 전위 순회

#### 트리 중위 순회 (= 대칭 순회)
 * ![중위순회1](../../assets/images/2023-09-30-study005/img_8.png)
 * 왼쪽 서브트리 중위 순회 → 루트 → 오른쪽 서브트리 중위 순회
 * ![중위순회2](../../assets/images/2023-09-30-study005/img_5.png)

<span style = "color : #8e8b82; font-size: smaller;">
솔직히 중위가 제일 헷갈리는데 그냥 Λ Λ Λ Λ Λ 이런 느낌으로 왔다갔다 반복한다고 생각하니 할만했다
</span>


#### 트리 후위 순회
  * ![후위순회1](../../assets/images/2023-09-30-study005/img_6.png)
  * 왼쪽 서브트리 후위 순회 → 오른쪽 서브트리 후위 순회 → 루트 
  * ![후위순회2](../../assets/images/2023-09-30-study005/img_7.png)

다시 문제로 돌아가서 
  1. 전위 순서 : A-B-D-F-C-E-G-H
  2. 중위 순서 : B-D-F-A-C-G-E-H
  3. 후위 순서 : F-D-B-G-H-E-C-A 



<br>


|   나의 답   |
|:--------:|
| 1) G/E/C | 

<br>

> 이미지&내용 출처

 * <https://withhamit.tistory.com/282>
 * <https://blog.naver.com/sedi1017/223144612932>

<br><br><br>


---

### 19번 문제
해싱을 이용한 파일 구조로 옳은 것은?
1. 순차 파일
2. 다중 키 파일
3. 직접 파일
4. 색인 순차 파일

---

> 알아야 할 것과 정리



#### 자료 구조 - 형태에 따른 분류
  * ![자료구조형태분류](../../assets/images/2023-09-30-study005/img_9.png)



* 파일 : 고유한 이름을 갖는 것. 관련 정보 단위의 집합.
* 파일 시스템 
  * 보조 기억 장치에 저장돼 있는 파일들을 관리해주는 총제적인 기술 쳬계를 의미
  * 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제
  * 일반적으로는 HDD, CD-ROM같은 물리적인 것들을 가리킴.
  * 깊게는 파일 서버 상의 자료로의 접근을 제공하는 방식, 가상의 형태로서 접근 수단만이 존재하는 방식도 파일시스템 범위에 포함. 

<span style = "color : #8e8b82; font-size: smaller;">너무 깊어서 익사하는 줄.. 빠르게 넘어가자</span>

#### 파일 구조란? (GPT야, 아주 쉽게 설명해줘~)

1. 데이터를 파일에 저장하고 그 데이터를 읽고 쓰기 위한 논리적인 조직 방식
   * 파일은 일반적으로 0과 1로 이루어진 이진 데이터로 저장됩니다. 이진 데이터를 사용자가 이해하고 다루기 어렵기 때문에 파일 구조는 데이터를 보다 읽기 쉽고 이해하기 쉽게 구성하는 방법을 제공합니다.예를 들어, 텍스트 파일은 문자열 데이터를 줄 단위로 구조화하여 저장하는 파일 구조를 갖습니다. 각 줄은 텍스트로 표현된 데이터를 포함하고 있으며, 줄 바꿈 문자로 구분됩니다. 이러한 파일 구조는 텍스트 편집기에서 텍스트를 읽고 수정하기 용이하게 만들어줍니다.
   * 데이터베이스 파일은 테이블, 레코드, 필드와 같은 구조로 데이터를 저장하며, 이러한 파일 구조는 데이터를 효율적으로 검색하고 관리하기 위한 방법을 제공합니다.
2. 데이터에 접근하는 연산에 관한 것을 다룸
   * 텍스트 파일의 경우, 데이터는 문자열이 줄 단위로 저장되어 있고 각 줄은 개행 문자로 분리됩니다. 파일 구조가 이렇게 설계되면 데이터를 읽고 쓰기가 쉽고, 줄 단위로 데이터에 접근할 수 있습니다.
   * 데이터베이스 파일의 경우, 데이터는 테이블, 레코드 및 필드로 구성되며, 파일 구조는 데이터베이스 관리 시스템(DBMS)에서 정의됩니다. 이 구조에 따라 데이터를 삽입, 갱신, 삭제 및 검색하는 연산을 수행할 수 있습니다.
3. 파일 안에 저장된 데이터의 형태와 레코드 간의 관계를 결정
4. 데이터를 효과적으로 접근하고 처리하는 방법을 정의
5. 각 파일 구조는 특정 응용프로그램 또는 사용 사례에 가장 적합한 방식으로 데이터를 저장 및 관리

<span style = "color : #8e8b82; font-size: smaller;">가끔은 내용이 좀 길어도 이해만 잘되면 괜찮다고 생각한다.</span>


#### 주요 파일 구조

1. 순차 파일(Sequential File)
   * 데이터가 일렬로 연속적으로 저장
   * 순차 접근만 가능(판독 시에도 마찬가지)
   * 모든 데이터가 순서대로 기록됨 -> 저장공간의 낭비가 없음
   * 새로운 데이터를 삽입하거나, 삭제할 때 시간이 많이 걸림. 검색 효율 떨어짐
   * **사용**
     * 주로 순차적 시간 흐름에 따라 기록하는 로그 파일 
     * 미디어 스트리밍 로그, 주문 이력 로그 등
2. 인덱스 파일(= 색인 파일 = Indexed File)
   * 데이터가 키+값 세트로 저장됨
   * 키를 사용하여 레코드에 빠르게 접근 가능
   * 검색 속도가 빠르고 레코드 수정 및 삭제가 용이
   * **사용**
     * 주로 데이터베이스에서 레코드에 대한 빠른 검색 제공(B-트리, B+ 트리 인덱스)
     * 학생 성적 관리 시스템에서 ID로 성적 검색
3. 직접 파일(= 임의 접근 화일 = Direct File)
   * 레코드 단위로 저장됨. 레코드마다 고유 key를 가짐.
   * 해싱 함수(Hashing Function)를 이용하여 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장한다.
   * 레코드는 해싱함수에 의해 계산된 무리적 주소를 통해 접근 가능
   * **사용**
     * 레코드 위치를 직접 지정하거나 읽거나 쓸 수 있어 빠른 데이터 액세스 가능
     * 이진 파일 또는 바이너리 파일로 사용됨
     * 그림 파일, 멀티미디어 파일 저장에 사용.
     * 주식 거래 시스템에서 주식 가격 데이터를 저장하고 빠르게 검색.
4. 인덱스 순차 파일(= 색인 순차 파일 = Indexed Sequential File)
   * 색인+순차 파일 결합으로 데이터를 해시 테이블에 저장
   * 키를 사용한 레코드 검색과 순차적 접근을 모두 지원.
   * **사용**
     * 대용량 데이터 파일에서 특정 조건에 맞는 레코드 검색 시 사용
     * 도서 대출 목록을 저장하고 대출일, 도서ID 등으로 검색 사용
     * 물류 시스템에서 제품 인벤토리 정보를 저장하고 제품 ID 검색.
5. 해시 파일(Hash File)
   * 데이터를 해시 함수를 사용하여 저장.  (⇨ 해싱)
   * 주어진 키에 해당하는 데이터를 빠르게 찾을 수 있으며, 검색 시간이 상수 시간에 가깝다. (해시 함수를 사용하여 빠르게 검색)
   * **사용**
     * DB에 비밀번호 저장.
     * 복제 문서 판별
     * 파일 캐싱과 같은 시스템에서 데이터 검색 및 저장에 사용.
     * 해시 사용 예 <https://m.blog.naver.com/mage7th/221493776888>

<span style = "color : #8e8b82; font-size: smaller;">
<B>검색 시간이 상수 시간에 가깝다?</b><br> ⇨ 데이터 구조나 알고리즘이 특정 작업을 수행하는 데 걸리는 시간이 입력 데이터의 크기에 무관하게 일정하다는 것을 의미
<br> ⇨ 즉, 입력 데이터의 크기가 커져도 검색 시간이 일정하게 유지됨.
</span>


* 파일 캐싱 
  * 나중에 동일한 데이터에 빠르게 액세스 할 수 있도록 내 컴퓨터에 데이터를 저장하는 것.
  * 웹 페이지에 표시되는 이미지와 리소스는 내 컴퓨터에 캐시됨 ⇨ 다음 번 같은 웹 페이지를 방문 시, 내 컴퓨터의 캐시에서 이 데이터를 가져와서 웹 페이지를 더 빠르게 로드함.
  * ***데이터베이스***에서 쿼리 결과를 캐시에 저장하면 동일한 쿼리 반복 시 빠른 응답 제공됨.


<span style = "color : #8e8b82; font-size: smaller;">
뭔가 쿠키도 비슷한 거 아니었나? 찾아봄.
</span>


* 쿠키
  * 웹 서버와 웹브라우저 간의 정보 교환을 위한 작은 데이터 조각
  * 주로 사용자의 웹 경험을 개선하거나 사용자를 추적, 인증 정보를 저장하는 데 사용
  * 쿠키는 브라우저에서 관리됨.
  * ex) 로그인 정보 저장, 쇼핑카트 내용을 기억

<span style = "color : #8e8b82; font-size: smaller;">
다.름.
</span>

문제로 다시 돌아가서

#### 단일 키 파일
* 순차 파일 : 기본키에 따라 정렬된 순차 접근 지원
* 직접 파일 : 기본키에 따라 해싱 결과로 직접 접근 지원
* 색인순차 파일 : 기본키에 대해 만들어진 인덱스를 통해 직접 접근 및 키 값에 따른 순차 접근 지원

#### 다중 키 파일
* 하나의 데이터 파일에 대해 여러 다른 탐색 키를 이용하여 여러 접근 경로를 제공
* 사용되는 키는 보조키가 됨
* 보조키는 레코드가 유일하지 않을 수도 있음

<br>

|   나의 답   |
|:--------:|
| 3) 직접 파일 | 


<span style = "color : #8e8b82; font-size: smaller;">
19번 문제 풀면서 깨달은 점 : gpt 맹신하지 말자. 조장님이 늪에서 구해주심.
</span>
<br>

> 이미지&내용 출처

 * <https://developerjun2.tistory.com/149>



<br><br><br>


---

### 20번 문제
해시 함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의 값을 더하거나 배타적 논리합 연산을 통해 출력된 결과로 주소를 취하는 방법은?
1. 기수 변환법
2. 중간 제곱 방법
3. 제산 방법
4. 중첩 방법

---

> 알아야 할 것과 정리

#### 해시
  * 주어진 키를 이용해 실제 레코드 주소를 직접적으로 계산해 내는 것
  * 데이터 개수 n개와 무관하게 데이터를 빨리 찾기 위한게 궁극적임. 탐색 효율 O(1)을 지향한다고 함.
  * 키를 입력하면 해시함수를 통해서 해시테이블의 인덱스로 바로 접근함.

#### 정적 해싱 구현 기법
  * 기수 변환법 : 어떠한 진법으로 변환된 키를 다른 진법으로 간주하고 키를 변환하여 버킷 주소를 얻는 방법
  * 중간 제곱 방법 : 레코드 키 값을 제곱한 후에 결과 값의 중간 부분에 있는 몇 비트를 선택하여 해시 테이블의 홈 주소로 사용
  * 제산 방법 : 레코드키를 해시표의 크기보다 큰 수 중에서 가장 작은 소수로 나눈 나머지를 버킷 주소로 결정하는 방법
  * 무작위 방법 : 난수 발생 프로그램을 이용하여 난수를 발생시켜 키의 버킷주소를 결정하는 방법
  * 폴딩법(중첩 방법) : 키를 마지막 부분을 제외한 모든 부분의 길이가 동일하게 여러부분으로 나누고, 이들 부분을 모두 더하거나 XOR(배타적 논리합) 연산을하여 버킷 주소로 이용하는 방법
  * 경계 폴딩 : 원래의 키값을 여러부분으로 나눈 후, 나누어진 각 부분의 경계선을 종이 접듯이 접어 역으로 정렬한 후 같은 자리에 위치한 수를 더한 값을 버킷 주소로 사용하는 방법
  * 숫자 분석법(계수 분석법) : 키를 구성하는 수들이 모든 키들 내에서 각 자리별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿 수를 필요한만큼 선택하여 버킷 주소로 사용하는 방법

* XOR(배타적 논리합(排他的論理合, exclusive or)
  * 수리 논리학에서 주어진 2개의 명제 가운데 1개만 참일 경우를 판단하는 논리 연산이다. 약칭으로 XOR, EOR, EXOR라고도 쓴다.

정적 해싱 외에도 동적 해싱 및 확장 해싱이 있다. 자세한건 아래 링크를 ..
* <https://dev-kani.tistory.com/2>


<span style = "color : #8e8b82; font-size: smaller;">
더이상 깊게 빠져들지 않을래.. 힘들어
</span>

<br>

|    나의 답     |
|:-----------:|
| 4) 중첩 방법 | 





