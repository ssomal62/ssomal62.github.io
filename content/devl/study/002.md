---
layout : post
title : "자료구조 문제풀이 - 06~10"
date: 2023-09-29
summary: 
categories : [ 자료구조 ]
tags : [ study ]
---


---

### 6번 문제

다음 중 순서가 [A, B, C, D]인 자료를 스택에 입력하였다가 출력한 결과로 가능한 것은?

1. A, D, C, B
2. D, C, A, B
3. D, B, A, C
4. C, D, A, B

---

스택이면 후입선출인데, 단순히 D-C-B-A만을 생각했다. 근데 조조장님이 데이터를 쌓았다가 중간에 꺼내는 경우도 생각해야한단다.
1. A를 넣고 A를 꺼낸다. 그다음 B를 넣고 , C를 넣고, D를 넣는다. 꺼내면 D가 나오고, 그다음 C, 그다음 B. 가능하다.
2. D를 먼저 꺼냈다는건 다른 알파벳은 이미 스택에 쌓였거나, 이미 출력이 끝났거나. 전자의 경우 D-C-B-A 순으로만 가능하다.
3. 위와 동일
4. C를 꺼내본다. 하지만 C 밑에  D가 깔려 있을 순 없다. 

<br>

|     나의 답      |
|:-------------:|
| 1) A, D, C, B |

<br>

<span style = "color : #8e8b82; font-size: smaller;">
가능한 경우는 아래 7개인가? 더 있나? 헷갈리네..
</span>

* A-B-C-D / A-B-D-C / A-D-C-B / B-A-C-D / B-A-D-C / C-B-A-D / D-C-B-A



<br><br><br>

---

### 7번 문제

분할 정복(Dive and Conquer)에 기반한 알고리즘으로 피벗(pivot)을 사용하며 최악의 경우 n(n-1)/2회의 비교를 수행해야하는 정렬은?

1. Insertion Sort
2. Quick Sort
3. Bubble Sort
4. Selection Sort

---



<br>

|     나의 답      |
|:-------------:|
| 2) Quick Sort |

<br>



일단 분할 정복이며 피벗 개념을 사용하는 정렬은 이전 문제에서 한번 정리했다. 퀵정렬이다.
  * 헷갈렸는데 퀵정렬에서 n<sup>2</sup>는 시간복잡도라고한다. → O(n<sup>2</sup>)
  * 최대 비교 횟수는 n(n-1)/2회.




> 알아야 할 것과 정리

#### 삽입 정렬
  * 자료 배열의 요소를 앞에서부터 차례대로 이미 정렬된 부분과 비교하여 자신의 위치를 삽입.
  * 배열이 길어질수록 효율은 떨어지지만 구현이 간단함.
  * 선택 정렬이나 버블정렬과 같은  O(n<sup>2</sup>) 알고리즘보다 빠르고 안정적이며 in-place알고리즘이다.
  * 원리
    * 두번째 원소부터 비교 시작. 
    * ← 방향으로 첫번째 원소가 비교 대상. 첫번째 원소가 더 높은 숫자일 경우 첫번째 원소 이전 위치에 삽입.
    * 세번째 원소 비교 차례. 두번째 원소와 비교 후 조건이 성립하면 첫번째 원소와도 비교한다. 
    * 맞는 위치가 나오면 삽입
    * ![삽입정렬](/devl/study/img/002/img_3.png)

#### 선택 정렬
  * 제자리 정렬 알고리즘.
  * 버블정렬보다 두배 정도 빠름.
  * 어떻게 정렬이 되어 있든 일관성있게 n(n-1)/2에 비례하는 시간이 걸림.
  * 원리
    * 주어진 리스트 중 최소값을 찾는다.
    * 그 값을 맨 앞에 위치한 값과 교체한다. '패스(pass)'한다고 표현함.
    * 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
    * ![선택정렬](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)


대략적인 정렬은 다 훑어본 것 같으니

### 정렬 알고리즘 종합 비교

#### 1. 장단점 비교
![정렬알고리즘비교](/devl/study/img/002/img.png)

#### 2. 시간복잡도/공간복잡도 비교
![시간복잡도_공간복잡도비교](/devl/study/img/002/img_1.png)

<h4> <span style="font-size: smaller"> 이미지 출처</span></h4> <span style="font-size: smaller"> 정렬 알고리즘 : https://velog.io/@jaeyunn_15 </span>

<br><br><br>


---

### 8번 문제
다음 중 최악의 경우 검색 효율이 가장 <u>나쁜</u> 트리 구조는?

1. AVL 트리
2. 2-3 트리
3. 이진 탐색 트리
4. 레드-블랙 트리

---

> 알아야 할 것과 정리

#### 이진 탐색 트리 (Binary Search Tree)
  * 범위를 줄여나가면서 원하는 데이터를 검색하는 알고리즘
  * 분할 정복의 쉬운 예
  * 기존 이진 트리보다 탐색이 빠름. 높이가 h라면 O(h)의 시간복잡도를 가짐.
  * 노드 특징
    * 각 노드에 중복되지 않은 키가 있다.
    * 루트 노드 '왼쪽' 서브트리는 해당 노드보다 작은 키, '오른쪽' 서브트리는 큰 키.
    * 좌우 서브 트리도 모두 이진 탐색 트리여야 함.
  * 이러한 노드 특성 때문에 찾는 값이 노드보다 작을 경우는 왼쪽, 클 경우는 오른쪽으로 탐색.
    * ![img_6.png](/devl/study/img/002/img_6.png)
  * 이진 탐색 트리의 노드 삽입
    * ![img_7.png](/devl/study/img/002/img_7.png)




이진 탐색 트리는 연속적으로 낮은 수가 나올 경우 한쪽으로 노드가 쏠릴 수 있다. O(h)값만 높아짐
그것을 보완한게 AVL트리이다.

![이진탐색의편향성](/devl/study/img/002/img_8.png)

#### AVL 트리
  * 자가 균형 이진 탐색 트리.
  * 스스로 균형을 잡는 데이터 구조.
  * 임의의 이진 탐색 트리 T가 높이 균형 성질을 만족 할 때 AVL라고 함.
    * ![AVL트리](/devl/study/img/002/img_4.png)
  * 높이 균형 성질 : 트리 T는 모든 내부 노드 ν에 대하여 v의 자식 노드들의 높이 차이가 최대 1이다. (쉽게 말하면 노드가 쏠림없이 균형있게 이진 트리 형태로 배치되어 있기 때문에 각 노드 간의 그 높이 차이가 2가 나올 수 없다는 뜻)
  * 균형이 무너졌는지 판단할 때 Balance Factor(BF) 로 감지. BF가 1보다 커지면 회전을 통해 균형을 맞춰 높이 차이를 줄인다.
    * `BF(K) = K의 왼쪽 서브트리의 높이 - K의 오른쪽 서브트리의 높이`
    * BF가 -1,0,1 중 하나여야 하고 이를 벗어나면 회전을 진행하여 균형을 맞춘다..
    * ![AVL균형](/devl/study/img/002/img_9.png)
    * 회전의 종류 : Right Rotation, Left Rotation , LLCase, RRCase, LRCase, RLCase 
 
    
#### B트리
  * 2-3 Tree는 B트리의 일종이며 내부노드의 차수가 2 또는 3인 높이가 균형을 이룬 탐색트리.
  * 중복된 키 허용 안함
  * 일반 이진트리는 하향식 삽입인데 반해, B트리는 상향식 삽입 (삽입 시 root부터 내려오면서 비교하는 것이 아닌 leaf부터 위로 올라가면서 비교하는 방식)
  * ![B트리](https://upload.wikimedia.org/wikipedia/commons/6/65/B-tree.svg)
    * 숫자는 키값, 점은 포인터
  * 내부 노드의 자식 노드의 수가 미리 정해진 범위 내에서 변경 가능함. (2-3트리의 경우 노드 2개 또는 3개의 자식 노드를 가질 수 있고 이를 넘기면 해당 내부 노드는 부적절한 상태에 있다고 함)
  * 노드 접근 시간이 노드에서의 연산시간에 비해 길 경우 바른 방식보다 B트리가 상당한 이점을 지닌다.
    * → 각 내부 노드의 자식 노드의 수를 최대화해서 트리높이 감소, 그로 인해 균형을 맞추는 작업이 덜 필요하게 됨. 결국 효율이 증가.
  * 탐색 방식은 이진 탐색 트리와 동일하게 하향식 비교. 
  * 방대한 양의 저장된 자료를 검색해야 하는 경우 검색어와 일일이 비교해야해서 비효율적.

<span style ="font-size : x-small">이미 충분히 복잡한데 B+트리, B*트리도 있다고 한다.</span>


#### 레드-블랙 트리
  * 자가 균형 이진 탐색 트리. 연관 배열 등을 구현하는데 쓰임
  * 각각의 노드가 레드 or 블랙의 속성을 가짐.
  * 이진 탐색 트리 + 아래 조건을 만족해야 레드-블랙 트리가 됨
    1. 노드는 레드 or 블랙.
    2. 모든 리프 노드(=NIL) 와 루트 노드는 블랙이다.
    3. 레드 노드의 자식은 모두 블랙. (레드 노드의 자식 또는 부모는 레드 노드가 될 수 없다.)
    4. 리프부터 루트까지의 모든 동선에서 Black 노드 갯수는 같다.
    * ![레드블랙트리](/devl/study/img/002/img_10.png)
  * 레드-블랙 트리 삽입 과정
    1. 새로운 노드는 항상 레드로 삽입 
    2. 위 3번에 위배(= Double Red) 되므로 Restructuring이나 Recoloring 회전 과정을 통해 균형을 잡아줌.
  * 밸런스를 잡는 추가 연산이 필요하지만, 높이 감소 덕분에 요소 개수가 늘어날수록 이진 탐색트리와는 극명한 성능 차이가 있음.
  * 이진 탐색 트리의 단점을 해소하고, AVL트리보다는 조금 더 밸런스에 여유를 둬서 삽입, 삭제, 검색에 안정적임.

#### 시간복잡도 비교

|종류	|삽입	|삽입(최악)	|검색	|검색(최악)	|삭제|	삭제(최악)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|이진탐색트리	|O(log N)	|O(N)	|O(log N)|	O(N)	|O(log N)|	O(N)|
|링크드리스트	|O(1)	|O(1)|	O(N)|	O(N)	|O(N)	|O(N)|
|레드블랙트리|	O(log N)|	O(log N)|	O(log N)|	O(log N)|	O(log N)|	O(log N)|
|해시테이블|	O(1)|	O(N)|	O(1)	|O(N)|	O(1)|	O(N)|


#### 기타
  * O(h) : 트리 높이에 관련된 시간 복잡도 
    * 트리 구조에서 사용
    * 일반적으로 트리를 탐색하는 연산에 대한 시간 복잡도를 나타냄
  * O(logN) : 데이터 구조에서 탐색 또는 검색 연산에 대한 시간 복잡도 
    * N은 데이터의 개수 또는 크기
    * 데이터가 많아져도 로그 시간으로 증가하기 떄문에 매우 효율적인 알고리즘.
    * 배열, 이진 탐색 트리에서 사용

<br>

|     나의 답      |
|:-------------:|
| 3) 이진 탐색 트리|

<span style = "color : #8e8b82; font-size: smaller;">
검색에 있어 균형 있는 트리의 경우 O(h)의 시간복잡도를 가지나, 그렇지 않은 트리는 O(n)의 시간복잡도를 가지게 된다. (h:높이, n:노드의 수)
보기에서 균형 속성이 없는 트리는 이진 탐색 트리이다.
</span>

<br>

> 이미지&내용 출처

이진탐색
* <https://code-lab1.tistory.com/10>

AVL탐색
* <https://ko.wikipedia.org/wiki/AVL_%ED%8A%B8%EB%A6%AC>
* <https://code-lab1.tistory.com/61>

트리의 개념과 종류
* <https://code-lab1.tistory.com/8>

B트리/2-3트리
* <https://ttl-blog.tistory.com/721#2-3%20Tree-1>
* <https://rebro.kr/169>
* <https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC>

레드-블랙트리
* <https://code-lab1.tistory.com/62>
* <https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC>
* <https://hotfoxy.tistory.com/102>
<br><br><br>

___

### 9번 문제
다음 그래프에서 정점 A를 선택해 깊이우선탐색(DFS)으로 운행한 결과로 옳은 것은?

![img.png](/devl/study/img/002/img_11.png)

---

> 알아야 할 것과 정리

#### 깊이우선탐색(DFS, Depth-First Search)
  * 그래프 순회 방식의 일종.
  * 일반적으로 재귀호출을 사용하여 구현. 또는 스택 배열로 구현. (스택 오버플로우 주의 필요)
  * 작동 방식
    1. 한 루트로 최대한 깊숙이 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방식.
    2. 갈림길이 나타날 떄 '다른 길이 있다'는 정보만 기록하고 지나간 길은 지워나감.
    3. 막다른 곳에 도달하면 직전 갈림길까지 돌아가 (다시 부모노드로 돌아오는 것을 백트래킹이라 함) '이 길은 아님'이라는 표식을 남김
    4. 갈림길을 순차적으로 탐색하다 목표에 도달하면 종료.
  * 검색 속도는 BFS에 비래 느림. 단, 검색이 아닌 순회를 할 경우 많이 사용됨.
  * 단점 : 해가 없는 경로에 깊이 빠질 가능성이 있다. 얻어진 해가 최단 경로가 된다는 보장이 없다.
  * 장점 : 목표 노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.
  * ![DFS](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Depth-First-Search.gif/220px-Depth-First-Search.gif)


일단 위 이론대로 하면 트리에서 DFS 순서는 알겠는데. 위 예제는 그래프이다.

주의할 건 라인 이동을 우선으로하고 백트래킹의 경우 오름차순을 적용하면 된다고한다. 둘 중 더 값 작은 것.
![그래프DFS](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2123283A51FF79DB46)

다시 문제로 돌아가자.
  1. 일단 B, C, D중 오름차순에 의해 B루트 진입. 연결선 끝까지 간다. B-E-F-G.
  2. 더이상 내려 갈 길이 없기 때문에 백트래킹. C 에서 F, D, A 중 A와 F는 false 상태이기 때문에 D로 이동.



|       나의 답       |
|:----------------:|
| 3) A-B-E-F-G-C-D |

<span style = "color : #8e8b82; font-size: smaller;">
+1) 조장 질문 찬스 씀.
</span>
<br>
<span style = "color : #8e8b82; font-size: smaller;">
+2) 깊이우선탐색은 너비우선탐색과 자주 비교된다고 함
</span>


<br>

> 이미지&내용 출처

깊이우선탐색
  * <https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89>
  * <https://blog.hexabrain.net/268>
<br><br><br>

___

### 10번 문제
다음은 스택의 자료 삭제 알고리즘이다. ㉠에 들어갈 내용으로 옳은 것은? (단, Top은 스택 포인터이고, S는 스택의 이름이다.)
```cpp
If Top = 0 Then
　( ㉠ )
Else {
　remove S(Top)
　Top = Top – 1
}
```
 ① Overflow     ② Top = Top + 1     ③  call    ④ Underflow

---

> 알아야 할 것과 정리

#### 오버플로우(OverFlow)
  * 변수가 표현할 수 있는 최대의 범위를 넘어가는 경우

#### 언더플로우(UnderFlow)
  * 변수가 표현할 수 있는 최소의 범위를 넘어가는 경우 (오버플로우와는 반대)

> 예~~전에 '문명'이라는 게임에서 간디의 폭력성 수치가 언더플로우로 인해 최대치를 찍었다는 이슈가 생각이 났다.
> * [문명과 언더플로우]  <https://blog.naver.com/ruvendix/220776347049>

![언더플로오버플로](/devl/study/img/002/img_12.png)


#### 하지만?

<details>
<summary>하지만?이 궁금하다면 (열기)</summary>
<div markdown="1">   

그런데... 찾다보니 이런 얘기가 있다.
1999년까지만 해도 underflow, overflow라고 했지만, 2000년 초반 C표준이 개정되면서 단순하게 표현범위를 벗어나면 overflow라고 바꾸어 정의했다고한다.

![오버플로](/devl/study/img/002/img_13.png)
* 출처 <https://80000coding.oopy.io/10d17093-d9cd-4edb-8d2b-55a4bff86565>

그러나 업계에서는 언더플로우와 오버플로우로 나눠 커뮤니케이션이 되고 있는 것이 현실.

10번 지문의 if문은 스택에 쌓인 데이터가 0일 때 삭제를 시도할 경우를 나타내는 것이다. 그렇다면 언더플로우가 맞을 것 같긴한데..
학문적으로 바라본다고 했을 때 답은 언더플로우라고 하면 안되는 것인가? 되는 것인가? 

조조장의 생각이 궁금해지는 문제이다.

---
조조장님께 물어보고 피드백을 받았다.

내가 찾은 블로그 내용을 보면 정수에 한하는 내용이라고. 무려 내가 싫어하는 영어로 된 자료 사이트도 보내주셨다.
일단 
  * 마소에서는 언더플로어 용어를 사용하고 있고,
    * <https://learn.microsoft.com/ko-kr/cpp/sanitizers/error-stack-buffer-underflow?view=msvc-170>
  * C표준에서 integer에서 연산 결과가 표현범위의 최소값 미만이 되면 underflow, 최대값을 초과하면 overflow
       컴퓨터공학에서 용어 underflow는 부동소수점과 stack에서 쓰인다.
    * <https://en.wikipedia.org/wiki/Stack_(abstract_data_type)>


라고 보내주심

* 나 : 근데 10번 문제에 stack의 개수는 실수로 나타낼 수 없지 않나요?

* 조조장 : 오버플로우 언더플로우는 단순히 정수형이 아니고 현재 최상단 등을 가리키는 포인터인데..

* 나 : 화살표처럼 생각하면 되나요?

* 조조장 : [스택을 구현하는 방법중에 연결리스트로 구현한 거..](https://www.cs.usfca.edu/~galles/visualization/StackLL.html)

* ![StackExam](/devl/study/img/002/img_14.png)

* 나 : 화살표가 포인터라는 건가요?
* 조조장 : Top이 포인터죠. 자료를 push하면 그 값을 가리키게 바뀌면서 스택에 데이터를 넣으니까, 가장 최근에 삽입된 데이터 를 가리키는 ^^;;;;;;;
* 나 : 아 알겠다, 알겠다.

조장님이 질문폭탄에 어지럽다고해서 그만하기로 했다. (뭔가 아쉬움)

</div>
</details>

<br>

|     나의 답      |
|:-------------:|
| 4) UnderFlow |

<br>

> 이미지&내용 출처

오버플로우와 언더플로우
* <https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89>
* <https://dojang.io/mod/page/view.php?id=32>
  <br><br><br>
