---
layout : post
title : "자료구조 문제풀이 - 01~05"
date: 2023-09-29
summary: 
categories : [ 자료구조 ]
tags : [ study ]
---


항상 팀원의 성장을 바라시는 조조장님께서 추석 과제로 자료구조 문제를 내주셨다. 찾아보며 푸는 일명 노베이스에 욱여넣기.

시작 전에 자료구조는 왜 배워야하는 지 찾아보았다.

### 자료구조는 왜 배워야 할까?
1. 자료구조의 내부를 이해하면 처리 속도, 메모리의 효율 등 상황에 맞춰 최대한 성능을 잘 뽑아 낼 수 있는 자료구조를 선택 할 수 있게된다. 
2. 알고리즘 데이터를 효율적으로 사용할 수 있게 도와주는 것. 자료구조를 모르면 알고리즘을 공부하는 데 어려움이 있다.

---

### 1번 문제
다음 중 자료구조에 대한 설명으로 옳지 <u>않은</u> 것은? 
1. 스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다.
2. 큐는 비선형구조에 해당한다.
3. 큐는 First In - Frist Out 처리를 수행한다.
4. 스택은 Last In - First Out 처리를 수행한다.

---

> 알아야 할 것과 정리

#### 스택(Stack) 개념
  * 데이터 구조 : 후입선출 (LIFO)
  * 활용 예 : 웹브라우저 뒤로가기, 실행 취소(Undo), 수식의 괄호 검사, 역순 문자열 만들기 등


#### 큐(Queue) 개념
  * 큐는 '줄을 서서 기다린다'는 의미. 
  * 데이터 구조 : 선입선출 (FIFO)
  * 활용 예 : 은행 업무, 맛집 대기 등 일상생활에서 줄서서 기다리는 행동. 캐시 구현.



#### 비선형구조 (+ 선형 구조) 개념
  * 선형 구조 : 자료를 구성하는 원소들을 하나씩 순차적으로 나열.
    * → 배열, 리스트, 스택, 큐
    * ![선형구조](/devl/study/img/001/img_2.png)
  * 비선형 구조 : 하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 형태.
    * → 트리, 그래프
    * ![비선형구조](/img/001/img_1.png)


#### 자료구조 
![자료구조](/img/001/img.png)

#### 기타
* 서브루틴 호출 : 프로그램 내에서 다룬 부분의 코드를 재사용하기 위해 작성된 코드블록 또는 함수.
    ```java
    public class SubroutineExample {
        public static void main(String[] args) {
            int result = addNumbers(5, 7); // 서브루틴 호출
            System.out.println("Result: " + result);
        }
    
        public static int addNumbers(int a, int b) {
            int sum = a + b;
            return sum; // 서브루틴 반환
        }
    }
    ```

* 인터럽트 처리 :  일반적으로 외부에서 발생하는 이벤트나 상황으로, 프로세스나 스레드의 실행 흐름을 중단하고 특별한 처리를 할 수 있게 함.

<span style = "color : #8e8b82; font-size: smaller;">
예시 코드를 넣기엔 너무 길어서, 그냥 '인터럽트는 스택 방식으로 처리한다'라고만 알고있자.
</span>

#### ADT(Abstract Data Types)
* 자료구조의 동작 방법을 표현하는 데이터 형식. 
* 말은 어려워 보이나 List로 따지면 `.get()`, `.append()`, `.insert()`, `.remove()` 같은 기능을 말하는 것.


<br>

|나의 답 |
|:------------------:|
|    2. 큐는 비선형구조에 해당한다.                 |

<br>


<h4> <span style="font-size: smaller"> 이미지 & 내용 출처</span></h4>

* <span style="font-size: smaller">스택/큐 : <https://devuna.tistory.com/22></span>
* <span style="font-size: smaller">자료구조 : <https://m.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8073601837></span>

<br><br><br>


---

### 2번 문제
레코드가 다음과 같이 구성되어 있을 때, 이진 검색으로 '11'을 찾으려 한다. 비교횟수는 몇 번인가?
> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

---


> 알아야 할 것과 정리

#### 레코드의 개념

* 기본적인 자료구조.
* 데이터베이스 또는 스프레드 시트에서는 레코드를 ROW라고 부름.
* 객체지향 프로그래밍에서는 멤버라고 불림.
* 일반적으로 고정 숫자나 시퀀스로 이루어짐.
* 학생 성적 리스트로 본 예
  
  |  이름  |     나이      |     평균     |    학점     |
  |:----:|:-----------:|:----------:|:---------:|
  | 김나나  |     15      |    77.5    |     C     |
  | 이이진  |     15      |    89.5    |     B     |
  
  <cite>- 학생 성적 레코드는 이름, 학번, 평균, 학점 필드로 구성됨</cite>

#### 이진 탐색
1. 중간값을 찾는다
2. 중간값 기준으로 찾는 값이 포함되어 있지 않은 범위는 버린다.
3. 남은 범위에서 다시 중간값을 찾는다. 새로운 중간값 기준으로 찾는 값이 포함되지 않은 범위는 버린다.
4. 이 과정을 반복 한 것.

* 그런데 홀수 범위의 중간값은? 
  * 위 문제에서는 중간값이 7.5가 나오는데, 이진 탐색에서는 소수점은 버린다고 한다. 그러니 비교 시작점을 7부터 보면 된다.




<br>

| 나의 답  |
|:-----:|
| 3) 4회 |

<br>


<h4> <span style="font-size: smaller"> 이미지 & 내용 출처</span></h4>

* <span style="font-size: smaller">레코드 : <https://ko.wikipedia.org/wiki/%EB%A0%88%EC%BD%94%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)></span>
* <span style="font-size: smaller">이진탐색 : <https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89></span>


<Br><Br><Br>

---

### 3번 문제

<details>
<summary>3번은 쉬워서 스킵</summary>
<div markdown="1"> 
다음은 입력된 배열을 오름차순으로 정렬하는 코드이다.

㉠, ㉡에 들어갈 내용으로 올바르게 짝지어진 것은?

```cpp
#include <stdio.h>

void swap(int a[], int idx1, int idx2) {
  int t = a[idx1];
  a[idx1] = a[idx2];
  a[ ㉠ ] = t;
}

void sort(int a[], int len) {
  for (int i = 0; i < len - 1; i++) {
  for (int j = 0; j < len - i - 1; j++) {
    if (a[j] > a[j + 1])
      swap(a, j, j + 1);
    }
  }
}

int main() {
  int nx = 5;
  int a[] = {5, 15, 7, 20, 11};
  sort(a, ㉡ );
  for (int i = 0; i < nx; i++)
  printf("%d ", a[i]);
  return 0;
}
```

<br>

|     나의 답      |
|:-------------:|
| ㉠ idx2  ,㉡ nx |

<br>

</div>
</details>

---

### 4번 문제

다음 중 정렬에 대한 설명으로 옳지 <u>않은</u> 것은?
1. 퀵 정렬은 스택을 이용해 수행한다.
2. 힙 정렬은 배열을 이용한 완전 이진 트리를 사용한다.
3. 5개의 원소를 가진 배열을 버블 정렬로 정렬하면 최대 20번의 비교 연산은 수행한다.
4. 쉘 정렬은 최적의 경우 선택 정렬보다 빠르다.

---

> 알아야 할 것과 정리

#### 퀵 정렬
  * 분할 정복 알고리즘의 일종
  * 스택을 활용하는 재귀 알고리즘.
  * 컴퓨터로 가장 많이 구현된 정렬 알고리즘 중 하나. 그러나 불안정한 정렬로 꼽음.
  * 정렬 갯수가 n개 일 때, 최악의 경우 n<sup>2</sup>번 비교 수행.
  * 원리
    * 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
    * 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
    * 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
    * 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
  * ![퀵정렬](/img/001/img_3.png)

#### 힙 정렬
  * 일단 힙에 대해 알아야함. 
    * 힙은 항상 완전 이진 트리.
    * 전체 정렬 목적모다는 가장 큰 수 (또는 가장 작은 수)의 몇 개의 값만 필요할 때 유용함.
    * 부모의 값은 항상 자식들의 값보다 크거나 작아야 함.
    * 데이터 삽입 시 가장 끝자리에 노드를 삽입 후 부모 노드와 비교해서 규칙에 맞지 않을 경우 부모와 값과 교환.
  * 힙 정렬 원리
    1. 일단 힙에 데이터를 모두 넣는다. (최소 힙트리 or 최대 힙트리 규칙에 따라.)
    2. 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다. 
    3. 가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.
    4. 2-3번 과정을 반복한다.

  * ![힙정렬1](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Sorting_heapsort_anim.gif/220px-Sorting_heapsort_anim.gif)
  * [위 이미지로도 이해가 안돼서 찾은 그나마 이해가 쉬운 영상(링크)](https://i.namu.wiki/i/4UpVN8_jIMSGVFYYfmFRaa6OIiymaBn9tY0hOfq4Q5aHmClpmTFX2s9wH5vEDCyq7SQgRiretf6ZmpUtBKAf_w.mp4)


#### 버블 정렬
  * 시간복잡도가 상당히 느리지만 코드가 단순해서 자주 사용됨.
  * 버블 정렬은 기본적으로 배열의 두 수 a, b를 선택
  * 두 수가 정렬되었다면 그대로 두고 아니라면 두 수를 바꿈.
  * 거의 모든 상황에서 최악의 성능을 보여줌.
  * ![버블정렬](../../assets%2Fimages%2F2023-09-30-study004%2Fimg_8.png)

#### 쉘 정렬
  * 삽입 정렬의 성질을 이용, 삽입 정렬의 장점은 살리고 단점은 보완.
  * 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬보다 더욱 빠르게 수행된다.
  * 삽입 정렬과는 다르게 셸 정렬은 전체 리스트를 한번에 정렬하지 않음.
  * 정렬을 거의 마친 상태의 리스트일수록 효율적이다.
  * 성능은 힙정렬 등에 버금 갈 정도로 빠름.
  * 원리
    * 먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류
    * 연속적이지 않은 여러 개의 부분 리스트를 생성
    * 각 부분 리스트를 삽입 정렬을 이용하여 정렬
    * 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복
    * 위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복
    
    * ![쉘정렬](/img/001/img_5.png)


<br>

|                        나의 답                        |
|:--------------------------------------------------:|
| 3) 5개의 원소를 가진 배열을 버블 정렬로 정렬하면 최대 20번의 비교 연산은 수행한다. |

<span style = "color : #8e8b82; font-size: smaller;">
버블 정렬 최악의 수행 횟수 : n(n-1)/2 로 원소가 5개라면 최대 10번을 수행함.!
</span>


<br>

<h4> <span style="font-size: smaller"> 이미지 & 내용 출처</span></h4>

* <span style="font-size: smaller">정렬 알고리즘 : <https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98></span>
* <span style="font-size: smaller">셸 정렬 : <https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html> </span>
* <span style="font-size: smaller">퀵 정렬 : <https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html></span>

<Br><Br><Br>
### 5번 문제

다음은 스택에 자료를 삽입하는 알고리즘이다. 괄호 안에 들어갈 내용으로 옳은 것은? (단, n은 스택의 최대크기이다.)
```cpp
procedure Insert(element, n, top, Stack)
　if (top ≥ n) then
　　call Stack → Full;
　end if;
　top = top + 1;
　Stack(top) = ( );
end Insert
```

---

<br>

|    나의 답    |
|:----------:|
| 4) element |


<span style = "color : #8e8b82; font-size: smaller;">
솔직히 코드 내용은 잘 모르겠으나, 파라미터 가 쓰이지 않았으니 element로 선택!
</span>
* 파라미터가 쓰이지 않을 때 오류가 발생할까? 
  * Java,C++ 모두 경고 메세지 정도로만 알려주고 컴파일은 정상적으로 됨.

<br>



